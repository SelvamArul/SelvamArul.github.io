<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://selvamarul.github.io//feed.xml" rel="self" type="application/atom+xml"/><link href="https://selvamarul.github.io//" rel="alternate" type="text/html" hreflang="en"/><updated>2026-02-28T21:08:29+00:00</updated><id>https://selvamarul.github.io//feed.xml</id><title type="html">blank</title><subtitle></subtitle><entry><title type="html">Rust vs. Go error handling</title><link href="https://selvamarul.github.io//blog/2026/Rust-Error/" rel="alternate" type="text/html" title="Rust vs. Go error handling"/><published>2026-02-13T15:09:00+00:00</published><updated>2026-02-13T15:09:00+00:00</updated><id>https://selvamarul.github.io//blog/2026/Rust-Error</id><content type="html" xml:base="https://selvamarul.github.io//blog/2026/Rust-Error/"><![CDATA[<p>Lately, I’ve been programming a lot in Go and Rust. During my Ph.D. years, most of my research code—particularly machine learning (ML) code—was written in Python, and C++ was the primary language I used for programming with ROS. C was the first programming language I learned back in high school, and C++ followed soon after. I would even say my algorithmic thinking is shaped by C++ more than any other language. However, Go and Rust feel modern—although many experienced programmers would say the concepts are nothing new and have existed in other languages for decades. That’s a discussion for another day.</p> <p>Now, back to Go and Rust. I like the simplicity of Go. Features like built-in concurrency and garbage collection make programming in Go a pleasure. I feel as productive as I used to when writing vectorized NumPy code in Python. However, I can’t help but admire how much Rust keeps me from writing bad code. This philosophy is built into the core of the language and shows in every aspect of the language design. This week I noticed a subtle difference between error handling in Go and Rust that illustrates this.</p> <p>Let’s consider a simple function that reads file content. The following function uses idiomatic Go <a href="https://gobyexample.com/multiple-return-values">multiple return values</a> to return both a value and an error. In fact, the <code class="language-plaintext highlighter-rouge">os.Open</code> library function on line 8 also returns two values: a file handler and an error. Anyone even slightly familiar with Go should have seen the error handling pattern if <code class="language-plaintext highlighter-rouge">err != nil</code> used on line 13 many times. It’s idiomatic to handle errors immediately after a function call.”</p> <figure class="highlight"><pre><code class="language-go" data-lang="go"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
<span class="s">"os"</span>
<span class="s">"io"</span>
<span class="p">)</span>
<span class="k">func</span> <span class="n">readFileContent</span><span class="p">()</span> <span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
<span class="n">file</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">os</span><span class="o">.</span><span class="n">Open</span><span class="p">(</span><span class="s">"data.txt"</span><span class="p">)</span> <span class="c">// Returns both file AND error</span>
<span class="c">// DANGER: file might be nil, but it's still accessible!  </span>
 <span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
<span class="k">return</span> <span class="s">""</span><span class="p">,</span> <span class="n">err</span>
<span class="p">}</span>
<span class="n">content</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">io</span><span class="o">.</span><span class="n">ReadAll</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
<span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
<span class="k">return</span> <span class="s">""</span><span class="p">,</span> <span class="n">err</span>
<span class="p">}</span>
<span class="k">return</span> <span class="kt">string</span><span class="p">(</span><span class="n">content</span><span class="p">),</span> <span class="no">nil</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure> <p>Let’s compare this with error handling in Rust using <a href="https://doc.rust-lang.org/std/result/">Result</a> type.</p> <figure class="highlight"><pre><code class="language-rust" data-lang="rust"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fs</span><span class="p">::</span><span class="n">File</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">io</span><span class="p">::</span><span class="n">Read</span><span class="p">;</span>
<span class="k">fn</span> <span class="nf">read_file_content</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="nb">String</span><span class="p">,</span> <span class="nn">std</span><span class="p">::</span><span class="nn">io</span><span class="p">::</span><span class="n">Error</span><span class="o">&gt;</span> <span class="p">{</span>
<span class="c1">// File::open returns Result&lt;File, Error&gt;</span>
<span class="k">let</span> <span class="k">mut</span> <span class="n">file</span> <span class="o">=</span> <span class="nn">File</span><span class="p">::</span><span class="nf">open</span><span class="p">(</span><span class="s">"data.txt"</span><span class="p">)</span><span class="o">?</span><span class="p">;</span> <span class="c1">// Either succeeds OR returns early</span>
<span class="k">let</span> <span class="k">mut</span> <span class="n">content</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
<span class="n">file</span><span class="nf">.read_to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">content</span><span class="p">)</span><span class="o">?</span><span class="p">;</span> <span class="c1">// file is GUARANTEED to be valid here</span>
<span class="nf">Ok</span><span class="p">(</span><span class="n">content</span><span class="p">)</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure> <p>In this example, can return a value of <code class="language-plaintext highlighter-rouge">String</code> type if the functions succeeds wihtout any errors or value of tpye if an error occurs. Note that the library function also returns . The interesting aspect of Rust error handling is, in case of an error in <code class="language-plaintext highlighter-rouge">File::open</code> , the function immediately returns with and the rest if of the lines are not executed. Compare this with Go’s pattern that is not enfored by the compiler.</p> <p>In this example, <code class="language-plaintext highlighter-rouge">read_file_content</code> can return a value of <code class="language-plaintext highlighter-rouge">String</code> type if the function succeeds without any errors, or a value of <code class="language-plaintext highlighter-rouge">std::io::Error</code> type if an error occurs. Note that the library function <code class="language-plaintext highlighter-rouge">File::open</code> also returns <code class="language-plaintext highlighter-rouge">Result&lt;File, Error&gt;</code>. The interesting aspect of Rust error handling is that in case of an error in <code class="language-plaintext highlighter-rouge">File::open</code> , the function <code class="language-plaintext highlighter-rouge">read_file_content</code> immediately returns with <code class="language-plaintext highlighter-rouge">std::io::Error</code> and the rest of the lines are not executed. This is different from Go’s <code class="language-plaintext highlighter-rouge">err != nil</code> pattern, which is not enforced by the compiler.</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// This Go code compiles but crashes at runtime!</span>
<span class="k">func</span> <span class="n">brokenExample</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">file</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">os</span><span class="o">.</span><span class="n">Open</span><span class="p">(</span><span class="s">"nonexistent.txt"</span><span class="p">)</span> <span class="c">// file is nil, err is not nil</span>
    <span class="c">// Programmer forgets to check err...</span>
    <span class="n">content</span><span class="p">,</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">io</span><span class="o">.</span><span class="n">ReadAll</span><span class="p">(</span><span class="n">file</span><span class="p">)</span> <span class="c">// PANIC! Dereferencing nil pointer</span>
    <span class="nb">println</span><span class="p">(</span><span class="kt">string</span><span class="p">(</span><span class="n">content</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div></div> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// This Rust is IMPOSSIBLE to compile:</span>
<span class="k">fn</span> <span class="nf">broken_example</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">file</span> <span class="o">=</span> <span class="nn">File</span><span class="p">::</span><span class="nf">open</span><span class="p">(</span><span class="s">"data.txt"</span><span class="p">);</span> <span class="c1">// This is Result&lt;File, Error&gt;</span>
    <span class="c1">// file.read_to_string(&amp;mut String::new()); // COMPILER ERROR!</span>
    <span class="c1">// Cannot call methods on Result - must handle the error first!</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="programming-laguages"/><category term="rust"/><category term="go"/><summary type="html"><![CDATA[Rust vs. Go error handling]]></summary></entry><entry><title type="html">Direct Linear Transform: The Swiss Army Knife of Computer Vision</title><link href="https://selvamarul.github.io//blog/2026/DLT/" rel="alternate" type="text/html" title="Direct Linear Transform: The Swiss Army Knife of Computer Vision"/><published>2026-02-13T15:09:00+00:00</published><updated>2026-02-13T15:09:00+00:00</updated><id>https://selvamarul.github.io//blog/2026/DLT</id><content type="html" xml:base="https://selvamarul.github.io//blog/2026/DLT/"><![CDATA[<h3 id="introduction">Introduction</h3> <p>If you’ve ever wondered how your smartphone can seamlessly stitch together a panoramic photo, or how augmented reality apps can perfectly overlay digital objects onto the real world, you’ve witnessed the power of the Direct Linear Transform (DLT) in action. This elegant mathematical technique is one of the most fundamental tools in computer vision, quietly working behind the scenes in everything from 3D reconstruction to image registration.</p> <p>Despite its intimidating name, DLT is beautifully simple in concept: it’s a method for solving systems of linear equations that arise naturally in projective geometry. Today, we’ll explore what makes DLT so powerful, when to use it, and why it’s become the go-to solution for many computer vision problems.</p> <h3 id="what-is-the-direct-linear-transform">What is the Direct Linear Transform?</h3> <p>At its heart, DLT is a technique for solving homogeneous linear systems of the form \(Ax = 0\), where we want to find a non-trivial solution (meaning \(x ≠ 0\)). The “direct” in the name refers to the fact that we can solve these systems in closed form using Singular Value Decomposition (SVD), without iterative optimization.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kn">import</span> <span class="n">numpy</span> <span class="k">as</span> <span class="n">np</span>

<span class="k">def</span> <span class="nf">solve_dlt</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">
    Solve homogeneous system Ax = 0 using DLT

    Args:
        A: Design matrix (m x n where m &gt; n)

    Returns:
        x: Solution vector (the right singular vector
           corresponding to the smallest singular value)
    </span><span class="sh">"""</span>
    <span class="n">U</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">Vt</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="nf">svd</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">Vt</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># Right singular vector with smallest singular value
</span>    <span class="k">return</span> <span class="n">x</span>
</code></pre></div></div> <p>The mathematical beauty lies in the fact that the solution is always the <strong>right singular vector corresponding to the smallest singular value</strong> of the design matrix A. This vector minimizes \(\|Ax\|^2\) subject to the constraint \(\|x\| = 1\), giving us the “best” solution in a least-squares sense.</p> <h3 id="the-classic-example-estimating-fundamental-matrices">The Classic Example: Estimating Fundamental Matrices</h3> <p>Let’s dive into a concrete example that showcases DLT’s power: estimating the fundamental matrix between two camera views. The fundamental matrix encodes the epipolar geometry between two images and is crucial for stereo vision and 3D reconstruction.</p> <p><strong>The Epipolar Constraint</strong></p> <p>Given corresponding points \(x_1\) and \(x_2\) in two images, the epipolar constraint states:</p> \[x_2^T F x_1 = 0\] <p>where \(F\) is the 3×3 fundamental matrix. This constraint is inherently linear in the elements of \(F\)!</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">estimate_fundamental_matrix</span><span class="p">(</span><span class="n">points1</span><span class="p">,</span> <span class="n">points2</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">
    Estimate fundamental matrix using the 8-point algorithm

    Args:
        points1, points2: Corresponding points in two images (Nx2)

    Returns:
        F: 3x3 fundamental matrix
    </span><span class="sh">"""</span>
    <span class="n">n_points</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">points1</span><span class="p">)</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros</span><span class="p">((</span><span class="n">n_points</span><span class="p">,</span> <span class="mi">9</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n_points</span><span class="p">):</span>
        <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span> <span class="o">=</span> <span class="n">points1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span> <span class="o">=</span> <span class="n">points2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="c1"># Each point correspondence gives one linear constraint
</span>        <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">x1</span><span class="o">*</span><span class="n">x2</span><span class="p">,</span> <span class="n">x1</span><span class="o">*</span><span class="n">y2</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="o">*</span><span class="n">x2</span><span class="p">,</span> <span class="n">y1</span><span class="o">*</span><span class="n">y2</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>

    <span class="c1"># Solve using DLT
</span>    <span class="n">U</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">Vt</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="nf">svd</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
    <span class="n">F</span> <span class="o">=</span> <span class="n">Vt</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="nf">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

    <span class="c1"># Enforce rank-2 constraint for fundamental matrix
</span>    <span class="n">U_f</span><span class="p">,</span> <span class="n">S_f</span><span class="p">,</span> <span class="n">Vt_f</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="nf">svd</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>
    <span class="n">S_f</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># Set smallest singular value to zero
</span>    <span class="n">F_corrected</span> <span class="o">=</span> <span class="n">U_f</span> <span class="o">@</span> <span class="n">np</span><span class="p">.</span><span class="nf">diag</span><span class="p">(</span><span class="n">S_f</span><span class="p">)</span> <span class="o">@</span> <span class="n">Vt_f</span>

    <span class="k">return</span> <span class="n">F_corrected</span>

<span class="c1"># Example usage
</span><span class="n">points1</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([[</span><span class="mi">100</span><span class="p">,</span> <span class="mi">150</span><span class="p">],</span> <span class="p">[</span><span class="mi">200</span><span class="p">,</span> <span class="mi">180</span><span class="p">],</span> <span class="p">[</span><span class="mi">300</span><span class="p">,</span> <span class="mi">120</span><span class="p">],</span> <span class="p">[</span><span class="mi">150</span><span class="p">,</span> <span class="mi">250</span><span class="p">],</span>
                    <span class="p">[</span><span class="mi">250</span><span class="p">,</span> <span class="mi">200</span><span class="p">],</span> <span class="p">[</span><span class="mi">180</span><span class="p">,</span> <span class="mi">300</span><span class="p">],</span> <span class="p">[</span><span class="mi">320</span><span class="p">,</span> <span class="mi">180</span><span class="p">],</span> <span class="p">[</span><span class="mi">120</span><span class="p">,</span> <span class="mi">180</span><span class="p">]])</span>
<span class="n">points2</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([[</span><span class="mi">110</span><span class="p">,</span> <span class="mi">160</span><span class="p">],</span> <span class="p">[</span><span class="mi">210</span><span class="p">,</span> <span class="mi">190</span><span class="p">],</span> <span class="p">[</span><span class="mi">315</span><span class="p">,</span> <span class="mi">125</span><span class="p">],</span> <span class="p">[</span><span class="mi">155</span><span class="p">,</span> <span class="mi">260</span><span class="p">],</span>
                    <span class="p">[</span><span class="mi">260</span><span class="p">,</span> <span class="mi">210</span><span class="p">],</span> <span class="p">[</span><span class="mi">185</span><span class="p">,</span> <span class="mi">315</span><span class="p">],</span> <span class="p">[</span><span class="mi">335</span><span class="p">,</span> <span class="mi">185</span><span class="p">],</span> <span class="p">[</span><span class="mi">125</span><span class="p">,</span> <span class="mi">185</span><span class="p">]])</span>

<span class="n">F</span> <span class="o">=</span> <span class="nf">estimate_fundamental_matrix</span><span class="p">(</span><span class="n">points1</span><span class="p">,</span> <span class="n">points2</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">Fundamental matrix:</span><span class="sh">"</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>
</code></pre></div></div> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Fundamental matrix:
[[ 1.83175910e-06 -4.53604589e-04  1.52168585e-01]
 [ 4.51939741e-04  9.91235661e-06 -1.15264694e-01]
 [-1.46857708e-01  1.05231126e-01  9.64840705e-01]]
</code></pre></div></div> <p>With just 8 point correspondences, we can estimate the fundamental matrix that describes the geometric relationship between two camera views. This is the famous “8-point algorithm” that revolutionized computer vision in the 1990s.</p> <h3 id="the-dlt-toolbox-more-applications">The DLT Toolbox: More Applications</h3> <p>The fundamental matrix is just the beginning. DLT’s versatility shines through its application to numerous computer vision problems:</p> <h5 id="1-homography-estimation">1. Homography Estimation</h5> <p>For planar scenes or pure camera rotations, we can estimate 2D-to-2D projective transformations:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">def</span> <span class="nf">estimate_homography</span><span class="p">(</span><span class="n">points1</span><span class="p">,</span> <span class="n">points2</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">
    Estimate homography using DLT (4-point algorithm)
    </span><span class="sh">"""</span>
    <span class="n">n_points</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">points1</span><span class="p">)</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros</span><span class="p">((</span><span class="mi">2</span><span class="o">*</span><span class="n">n_points</span><span class="p">,</span> <span class="mi">9</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n_points</span><span class="p">):</span>
        <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span> <span class="o">=</span> <span class="n">points1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span> <span class="o">=</span> <span class="n">points2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="c1"># Two constraints per point correspondence
</span>        <span class="n">A</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="n">x1</span><span class="p">,</span> <span class="o">-</span><span class="n">y1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">x2</span><span class="o">*</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="o">*</span><span class="n">y1</span><span class="p">,</span> <span class="n">x2</span><span class="p">]</span>
        <span class="n">A</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">x1</span><span class="p">,</span> <span class="o">-</span><span class="n">y1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">y2</span><span class="o">*</span><span class="n">x1</span><span class="p">,</span> <span class="n">y2</span><span class="o">*</span><span class="n">y1</span><span class="p">,</span> <span class="n">y2</span><span class="p">]</span>

    <span class="n">U</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">Vt</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="nf">svd</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
    <span class="n">H</span> <span class="o">=</span> <span class="n">Vt</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="nf">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">H</span>
</code></pre></div></div> <h5 id="2-camera-calibration">2. Camera Calibration</h5> <p>DLT can estimate the full 3×4 camera projection matrix from 3D-2D correspondences:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">estimate_camera_matrix</span><span class="p">(</span><span class="n">points_3d</span><span class="p">,</span> <span class="n">points_2d</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">
    Estimate camera projection matrix using DLT
    </span><span class="sh">"""</span>
    <span class="n">n_points</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">points_3d</span><span class="p">)</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">zeros</span><span class="p">((</span><span class="mi">2</span><span class="o">*</span><span class="n">n_points</span><span class="p">,</span> <span class="mi">12</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">n_points</span><span class="p">):</span>
        <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Z</span> <span class="o">=</span> <span class="n">points_3d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">points_2d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="n">A</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">u</span><span class="o">*</span><span class="n">X</span><span class="p">,</span> <span class="o">-</span><span class="n">u</span><span class="o">*</span><span class="n">Y</span><span class="p">,</span> <span class="o">-</span><span class="n">u</span><span class="o">*</span><span class="n">Z</span><span class="p">,</span> <span class="o">-</span><span class="n">u</span><span class="p">]</span>
        <span class="n">A</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="n">v</span><span class="o">*</span><span class="n">X</span><span class="p">,</span> <span class="o">-</span><span class="n">v</span><span class="o">*</span><span class="n">Y</span><span class="p">,</span> <span class="o">-</span><span class="n">v</span><span class="o">*</span><span class="n">Z</span><span class="p">,</span> <span class="o">-</span><span class="n">v</span><span class="p">]</span>

    <span class="n">U</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">Vt</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="nf">svd</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
    <span class="n">P</span> <span class="o">=</span> <span class="n">Vt</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="nf">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">P</span>
</code></pre></div></div> <h5 id="3-3d-point-triangulation">3. 3D Point Triangulation</h5> <p>Given two camera views, we can reconstruct 3D points:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">def</span> <span class="nf">triangulate_point</span><span class="p">(</span><span class="n">P1</span><span class="p">,</span> <span class="n">P2</span><span class="p">,</span> <span class="n">point1</span><span class="p">,</span> <span class="n">point2</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">
    Triangulate 3D point from two camera views
    </span><span class="sh">"""</span>
    <span class="n">u1</span><span class="p">,</span> <span class="n">v1</span> <span class="o">=</span> <span class="n">point1</span>
    <span class="n">u2</span><span class="p">,</span> <span class="n">v2</span> <span class="o">=</span> <span class="n">point2</span>

    <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([</span>
        <span class="n">u1</span> <span class="o">*</span> <span class="n">P1</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">P1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
        <span class="n">v1</span> <span class="o">*</span> <span class="n">P1</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">P1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
        <span class="n">u2</span> <span class="o">*</span> <span class="n">P2</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">P2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
        <span class="n">v2</span> <span class="o">*</span> <span class="n">P2</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">P2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="p">])</span>

    <span class="n">U</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">Vt</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="nf">svd</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">Vt</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">X</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span> <span class="o">/</span> <span class="n">X</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>  <span class="c1"># Convert to Euclidean coordinates
</span></code></pre></div></div> <p>What Makes a Problem suitable for DLT? Not every computer vision problem can be solved with DLT. The technique works best when a problem has these characteristics:</p> <p><strong>Linear or Linearizable Constraints</strong> The relationships between the unknowns and measurements must be expressible as linear equations. This is where the magic happens in projective geometry—many seemingly complex geometric relationships become linear when expressed in homogeneous coordinates.</p> <p><strong>Scale Ambiguity</strong> DLT naturally handles problems where the solution is determined only up to scale. In projective geometry, this is often exactly what we want—a fundamental matrix \(F\) and \(2F\) represent the same epipolar geometry.</p> <p><strong>Overdetermined Systems</strong> We need more constraints (equations) than unknowns. This is why we need at least 8 points for fundamental matrix estimation (8 equations for 9 unknowns, minus the scale ambiguity).</p> <p><strong>Homogeneous Coordinates</strong> Problems involving projective transformations naturally fit the DLT framework because they work with homogeneous coordinates where scale doesn’t matter.</p> <h3 id="the-limitations-when-dlt-falls-short">The Limitations: When DLT Falls Short</h3> <p>While DLT is incredibly useful, it’s important to understand its limitations:</p> <h5 id="algebraic-vs-geometric-distance">Algebraic vs. Geometric Distance</h5> <p>DLT minimizes algebraic error (the residual in our linear equations), not geometric error (actual pixel distances). For the fundamental matrix, DLT minimizes:</p> \[\sum_{i} ( x_{2i}^T F x_{1i} = 0 )^2\] <p>This is not the same as minimizing the actual distance from points to their corresponding epipolar lines. For applications requiring high accuracy, DLT solutions are often used as initialization for nonlinear optimization methods.</p> <h5 id="sensitivity-to-noise">Sensitivity to Noise</h5> <p>DLT can be sensitive to noise, especially when the design matrix A is poorly conditioned. Preprocessing techniques like point normalization are often essential:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">def</span> <span class="nf">normalize_points</span><span class="p">(</span><span class="n">points</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">
    Normalize points for better numerical conditioning
    </span><span class="sh">"""</span>
    <span class="c1"># Translate to centroid
</span>    <span class="n">centroid</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">mean</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">points_centered</span> <span class="o">=</span> <span class="n">points</span> <span class="o">-</span> <span class="n">centroid</span>

    <span class="c1"># Scale so average distance from origin is sqrt(2)
</span>    <span class="n">avg_dist</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">mean</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="nf">norm</span><span class="p">(</span><span class="n">points_centered</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">scale</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">avg_dist</span>

    <span class="c1"># Normalization matrix
</span>    <span class="n">T</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">([[</span><span class="n">scale</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">scale</span> <span class="o">*</span> <span class="n">centroid</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
                  <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="o">-</span><span class="n">scale</span> <span class="o">*</span> <span class="n">centroid</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>
                  <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>

    <span class="c1"># Apply normalization
</span>    <span class="n">points_hom</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">column_stack</span><span class="p">([</span><span class="n">points</span><span class="p">,</span> <span class="n">np</span><span class="p">.</span><span class="nf">ones</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">points</span><span class="p">))])</span>
    <span class="n">points_norm</span> <span class="o">=</span> <span class="p">(</span><span class="n">T</span> <span class="o">@</span> <span class="n">points_hom</span><span class="p">.</span><span class="n">T</span><span class="p">).</span><span class="n">T</span>

    <span class="k">return</span> <span class="n">points_norm</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">],</span> <span class="n">T</span>
</code></pre></div></div> <h5 id="no-outlier-handling">No Outlier Handling</h5> <p>DLT assumes all our data points are good correspondences. In real-world scenarios, we often need to combine DLT with robust estimation techniques like RANSAC:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">ransac_fundamental_matrix</span><span class="p">(</span><span class="n">points1</span><span class="p">,</span> <span class="n">points2</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">max_iterations</span><span class="o">=</span><span class="mi">1000</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">
    Robust fundamental matrix estimation using RANSAC + DLT
    </span><span class="sh">"""</span>
    <span class="n">best_F</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">best_inliers</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">max_iterations</span><span class="p">):</span>
        <span class="c1"># Sample 8 random correspondences
</span>        <span class="n">sample_indices</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="nf">choice</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">points1</span><span class="p">),</span> <span class="mi">8</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="n">sample_points1</span> <span class="o">=</span> <span class="n">points1</span><span class="p">[</span><span class="n">sample_indices</span><span class="p">]</span>
        <span class="n">sample_points2</span> <span class="o">=</span> <span class="n">points2</span><span class="p">[</span><span class="n">sample_indices</span><span class="p">]</span>

        <span class="c1"># Estimate F using DLT
</span>        <span class="n">F</span> <span class="o">=</span> <span class="nf">estimate_fundamental_matrix</span><span class="p">(</span><span class="n">sample_points1</span><span class="p">,</span> <span class="n">sample_points2</span><span class="p">)</span>

        <span class="c1"># Count inliers
</span>        <span class="n">inliers</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">points1</span><span class="p">)):</span>
            <span class="n">x1</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">points1</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">x2</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">points2</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">error</span> <span class="o">=</span> <span class="nf">abs</span><span class="p">(</span><span class="n">x2</span><span class="p">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">F</span> <span class="o">@</span> <span class="n">x1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">error</span> <span class="o">&lt;</span> <span class="n">threshold</span><span class="p">:</span>
                <span class="n">inliers</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

        <span class="c1"># Update best model
</span>        <span class="k">if</span> <span class="nf">len</span><span class="p">(</span><span class="n">inliers</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nf">len</span><span class="p">(</span><span class="n">best_inliers</span><span class="p">):</span>
            <span class="n">best_F</span> <span class="o">=</span> <span class="n">F</span>
            <span class="n">best_inliers</span> <span class="o">=</span> <span class="n">inliers</span>

    <span class="k">return</span> <span class="n">best_F</span><span class="p">,</span> <span class="n">best_inliers</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="computer-vision"/><category term="3DV"/><summary type="html"><![CDATA[Understanding the mathematical foundation behind fundamental matrices, homographies, and camera calibration]]></summary></entry></feed>